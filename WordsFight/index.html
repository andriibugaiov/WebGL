<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Words Fight</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}

			#instructions {
				width: 100%;
				height: 100%;
				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script>

// mark - GamePlay

			var Helper = {};
			Helper.getSVGTextImage = function(str, callback){
		        var data = 'data:image/svg+xml,' + '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="400" height="400" viewBox="0 0 400 400"><text x="200" y="200" fill="black" font-size="30" style="text-anchor: middle; dominant-baseline: bottom;">'+str+'</text></svg>';
		        var img = new Image();
		        var canvas = document.createElement("canvas");
		        canvas.width = 400;
		        canvas.height = 400;
		        var ctx = canvas.getContext("2d");
		        img.onload = function() {
		            ctx.drawImage(img, 0, 0);
		            var pngImg = new Image();
		            pngImg.onload = function(){
		                svg = null;
		                canvas = null;
		                ctx = null;
		                img = null;
		                if(callback) 
		                	callback(pngImg);
		            }
		            pngImg.src = canvas.toDataURL("image/png")
		        };
		        img.src = data;
    		};
    		Helper.positionImageText = function(text, parent) {
		        this.getSVGTextImage(text, function(img){
		            var sprite = new THREE.Texture(img);
		            sprite.minFilter = THREE.LinearFilter;
		            sprite.needsUpdate = true;
		            var sp = new THREE.SpriteMaterial({
		                map: sprite,
		                color: 0xffffff
		            });
		            var mesh = new THREE.Sprite(sp);
		            mesh.position.y = 30;
		            mesh.scale.multiplyScalar(300);
		            parent.add(mesh);
		        });
    		};
	
			var Player = function () {
				// player object
				var size = 50;
				var geometryH = new THREE.BoxGeometry(size, 20, 20, 2, 2, 2); 
				var geometryV = new THREE.BoxGeometry(20, 20, size, 2, 2, 2); 
				var geometryRed = new THREE.MeshLambertMaterial({ 
					color: 0x903535
				});

				var objectV = new THREE.Mesh(geometryV, geometryRed);
				var objectH = new THREE.Mesh(geometryH, geometryRed);
				objectH.add(objectV);

				this.object = new THREE.Object3D();
				this.object.position.y = 10;
				this.object.add(objectH);

				// player attack filed
				var radius = 200;
				var geometry = new THREE.CylinderGeometry(radius, radius, 1, 32);
				var material = new THREE.MeshBasicMaterial({ 
					color: 0xff0000,
					transparent: true, 
					opacity: 0.2
				});
				this.attackField = new THREE.Mesh(geometry, material);
				this.attackField.radius = radius;
				this.object.add(this.attackField);



				// player contols
				this.movementControls = {
					movementParams: {
						// canJump: true,
						moveForward: false,
						moveBackward: false,
						moveLeft: false,
						moveRight: false,
						velocity: new THREE.Vector3()
					},
					onKeyDown: function (event) {
						var mp = this.movementParams;
						switch (event.keyCode) {
							case 38: // up
							// case 87: // w
								mp.moveForward = true;
								break;
							case 37: // left
							// case 65: // a
								mp.moveLeft = true; break;
							case 40: // down
							// case 83: // s
								mp.moveBackward = true;
								break;
							case 39: // right
							// case 68: // d
								mp.moveRight = true;
								break;
							// case 32: // space
							// 	if (mp.canJump === true ) 
							// 		mp.velocity.y += 350;
							// 	mp.canJump = false;
							// 	break;
						}
					},
					onKeyUp: function (event) {
						var mp = this.movementParams;
						switch(event.keyCode) {
							case 38: // up
							// case 87: // w
								mp.moveForward = false;
								break;
							case 37: // left
							// case 65: // a
								mp.moveLeft = false;
								break;
							case 40: // down
							// case 83: // s
								mp.moveBackward = false;
								break;
							case 39: // right
							// case 68: // d
								mp.moveRight = false;
								break;
						}
					}
				};

				var mc = this.movementControls;
				document.addEventListener('keydown', mc.onKeyDown.bind(mc), false);
				document.addEventListener('keyup', mc.onKeyUp.bind(mc), false);
			};
			
			var Bot = function (word) {
				this.word = word;
				this.rate = word.length;

				var size = Math.min(30, 4 * this.rate);
				var geometry = new THREE.BoxGeometry(size, size, size);
				var material = new THREE.MeshLambertMaterial({
					color: 0x808080
				});
				this.object = new THREE.Mesh(geometry, material);
				this.object.position.y = 10;

				Helper.positionImageText(this.word, this.object);
			};

			var Rocket = function () {
			};

// mark - 			
			
			var GamePlay = function (dictionary) {
				this.dictionary = dictionary;

				// canvas
				this.aspect = window.innerWidth / window.innerHeight;
				this.buttleFieldWidthTrue = 1000;
				this.buttleFieldHeightTrue = 1000;

				this.buttleFieldWidth = 1500;
				this.buttleFieldHeight = 1500;

				this.buttleFieldHeightTopDown = 1000;
				this.buttleFieldWidthTopDown = this.aspect * this.buttleFieldHeightTopDown;

				// graphics
				this.raycaster = null;
				this.scene = null;
				this.cameraTopDown = null;
				this.renderer = null;

				// game play
				this.prevTime = performance.now();
				this.bots = [];
				this.player = null;

				// initialization
				this.init.call(this);
				this.animate.call(this);
			};
			
			GamePlay.prototype.init = function () {
				this.initGraphics.call(this);

				this.initButtleField.call(this);
				this.initPlayer.call(this);
				this.initBots.call(this);
			};
			GamePlay.prototype.initGraphics = function () {
				// scene
				this.scene = new THREE.Scene();

				// camera
				var coef = 1;
				this.cameraTopDown = new THREE.OrthographicCamera(
					-0.5 * this.buttleFieldWidthTopDown * coef,
					0.5 * this.buttleFieldWidthTopDown * coef,
					0.5 * this.buttleFieldHeightTopDown * coef,
					-0.5 * this.buttleFieldHeightTopDown * coef,
					-0.00001, 1000000
				);
				this.cameraTopDown.position.set(1000, 1000, 1000);
				this.scene.add(this.cameraTopDown);

				this.cameraTopDown.lookAt(new THREE.Vector3());
				this.cameraTopDown.updateProjectionMatrix();
				

				// light
				var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
				light.position.set(0.5, 1, 0.75);
				this.scene.add(light);

				var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
				directionalLight.position.set(0.5, 1, 0.75);
				this.scene.add(directionalLight);
				
				// raycaster
				this.raycaster = new THREE.Raycaster(
					new THREE.Vector3(), 
					new THREE.Vector3(), 
					0, 1000000
				);

				// renderer
				this.renderer = new THREE.WebGLRenderer();
				this.renderer.setClearColor(0xffffff);
				this.renderer.setPixelRatio(window.devicePixelRatio);
				this.renderer.setSize(window.innerWidth, window.innerHeight);

				document.body.appendChild(this.renderer.domElement);
			};
			GamePlay.prototype.initButtleField = function () {
				// buttlefield
				var geometry = new THREE.PlaneGeometry(this.buttleFieldWidth, this.buttleFieldHeight, 10, 10);
				geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
				var material = new THREE.MeshLambertMaterial({
					color: 0xcccccc
				});
				var buttleField = new THREE.Mesh(geometry, material);
				this.scene.add(buttleField);

				// background
				var geometryBG = new THREE.PlaneGeometry(1000000, 1000000, 10, 10);
				geometryBG.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
				var materialBG = new THREE.MeshLambertMaterial({
					color: 0xeeeeee
				});
				var buttleFieldBackground = new THREE.Mesh(geometryBG, materialBG);
				buttleFieldBackground.position.y = -1;
				this.scene.add(buttleFieldBackground);

				// center
				var geometryBlue = new THREE.MeshBasicMaterial({ 
					// color: 0x353E90,
					color: 0xeeeeee
				});
				var size = 40;				
				var geometry = new THREE.CylinderGeometry(size, size, 1, 32);
				var center = new THREE.Mesh(geometry, geometryBlue);
				this.scene.add(center);
			};
			GamePlay.prototype.initPlayer = function () {
				// player
				this.player = new Player();
				var pObject = this.player.object;
				this.scene.add(pObject);
			};
			GamePlay.prototype.initBots = function () {
				for (var i = 0, flag = 0; i < this.dictionary.length; ++i, flag = 1 - flag) {
					var word = dictionary[i];

					var bot = new Bot(word);
					var bObject = bot.object;
					this.bots.push(bot);

					// TODO:
					var w = this.buttleFieldWidthTrue;
					var h = this.buttleFieldHeightTrue;

					var radius = this.player.attackField.radius
					var x = Math.max(Math.floor(Math.random() * w - w * 0.5));
					var z = Math.floor(Math.random() * h - h * 0.5);
					var coord = [x, z];
					for (var j = 0; j < coord.length; ++j) {
						coord[j] = (coord[j] <= 0) ? Math.min(-radius, coord[j]) : Math.max(radius, coord[j]);
					}
					bObject.position.x = coord[0];
					bObject.position.y = 10;
					bObject.position.z = coord[1];

					this.scene.add(bObject);
				}
			};		
			GamePlay.prototype.animate = function () {
				requestAnimationFrame(this.animate.bind(this));
				if (true) {
					var time = performance.now();
					var delta = (time - this.prevTime) * 0.001;

					// player animation
					var pObject = this.player.object;
					var mp = this.player.movementControls.movementParams;
					mp.velocity.x -= mp.velocity.x * 10.0 * delta;
					mp.velocity.z -= mp.velocity.z * 10.0 * delta;
					// mp.velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
					if (mp.moveForward) 
						mp.velocity.z -= 400.0 * delta;
					if (mp.moveBackward) 
						mp.velocity.z += 400.0 * delta;
					if (mp.moveLeft) 
						mp.velocity.x -= 400.0 * delta;
					if (mp.moveRight) 
						mp.velocity.x += 400.0 * delta;

					
					// var down = new THREE.Vector3(0, -1, 0);
					// this.raycaster.set(pObject.position, down);
					// this.raycaster.ray.origin.y -= 10; // players foot
					// var intersections = this.raycaster.intersectObjects(this.bots);
					// var isOnObject = intersections.length > 0;
					// if (isOnObject === true) {
					// 	mp.velocity.y = Math.max(0, mp.velocity.y);
					// 	mp.canJump = true;
					// }
					
					// if (pObject.position.y < 10) {
					// 	mp.velocity.y = 0;
					// 	pObject.position.y = 10; // players center
					// 	mp.canJump = true;
					// }

					pObject.translateX(mp.velocity.x * delta);
					// pObject.translateY(mp.velocity.y * delta);
					pObject.translateZ(mp.velocity.z * delta);

					// this.cameraTopDown.translateX(mp.velocity.x * delta);
					// this.cameraTopDown.translateY(mp.velocity.y * delta);
					// this.cameraTopDown.translateZ(mp.velocity.z * delta);

					// bots animation
					for (var i = 0, flag = 0; i < this.bots.length; ++i, flag = 1 - flag) {
						var bot = this.bots[i];
						var bObject = bot.object;

						var x = pObject.position.x - bObject.position.x;
						var y = 0;
						var z = pObject.position.z - bObject.position.z

						var toPlayerFromBot = new THREE.Vector3(x, y, z);
						toPlayerFromBot.normalize();
						
						var toBotFromPlayer = new THREE.Vector3(-x, -y, -z);
						toBotFromPlayer.normalize();

						this.raycaster.set(pObject.position, toBotFromPlayer);
						var intersections = this.raycaster.intersectObjects([bObject]);
						
						var target = toPlayerFromBot.clone();
					    if (intersections.length > 0 && intersections[0].distance > this.player.attackField.radius) { 
					    	var up = new THREE.Vector3(0, 1, 0);
					    	var toBotFromCenter = bObject.position.clone();
					    	if (flag) {
								target.crossVectors(toBotFromCenter, up);
					    	} else {
								target.crossVectors(up, toBotFromCenter);
					    	}
							target.normalize();
					    } 

						bObject.translateX(target.x * 10.0 * delta);
						bObject.translateY(target.y * 10.0 * delta);
						bObject.translateZ(target.z * 10.0 * delta);
					}
					this.prevTime = time;
				}
				this.renderer.render(this.scene, this.cameraTopDown);
			};

			var dictionary = ["car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication"];
			console.log("Dictionary length: " + dictionary.length);
			var gp = new GamePlay(dictionary);
		</script>
	</body>
</html>
