<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Words Fight</title>
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);
			}

			#instructions {
				width: 100%;
				height: 100%;
				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		<script src="three.min.js"></script>
		<script>

			var HashTable = function () {
				this.ht = {};
				this.size = 0;
			};
			HashTable.prototype.insert = function(key, value) {
				if (!this.ht.hasOwnProperty(key)) {
					++this.size;	
				} 
				this.ht[key] = value;
			};
			HashTable.prototype.remove = function(key) {
				if (this.ht.hasOwnProperty(key)) {
					delete this.ht[key];
					--this.size;
				}
			};
			HashTable.prototype.get = function(key) {
				if (this.ht.hasOwnProperty(key)) {
					return this.ht[key];
				}
				return null;
			};
			HashTable.prototype.contains = function(key) {
				if (this.ht.hasOwnProperty(key)) {
					return true;
				}
				return false;
			};
			HashTable.prototype.isEmpty = function() {
				return this.size < 1;
			};
			HashTable.prototype.getAllValues = function() {
				var all = [];
				for(var key in this.ht) {
    				all.push(this.ht[key]);
				}	
				return all;
			};	

			var Helper = {};
			Helper.getSVGTextImage = function(str, callback){
		        var data = 'data:image/svg+xml,' + '<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="400" height="400" viewBox="0 0 400 400"><text x="200" y="200" fill="black" font-size="30" style="text-anchor: middle; dominant-baseline: bottom;">'+str+'</text></svg>';
		        var img = new Image();
		        var canvas = document.createElement("canvas");
		        canvas.width = 400;
		        canvas.height = 400;
		        var ctx = canvas.getContext("2d");
		        img.onload = function() {
		            ctx.drawImage(img, 0, 0);
		            var pngImg = new Image();
		            pngImg.onload = function(){
		                svg = null;
		                canvas = null;
		                ctx = null;
		                img = null;
		                if(callback) 
		                	callback(pngImg);
		            }
		            pngImg.src = canvas.toDataURL("image/png")
		        };
		        img.src = data;
    		};
    		Helper.positionImageText = function(text, parent) {
		        this.getSVGTextImage(text, function(img){
		            var sprite = new THREE.Texture(img);
		            sprite.minFilter = THREE.LinearFilter;
		            sprite.needsUpdate = true;
		            var sp = new THREE.SpriteMaterial({
		                map: sprite,
		                color: 0xffffff
		            });
		            var mesh = new THREE.Sprite(sp);
		            mesh.position.y = 30;
		            mesh.scale.multiplyScalar(300);
		            parent.add(mesh);
		        });
    		};
    		Helper.keyToCharMap = new HashTable();
    		var keyCodesChars = ["a", 65,"b", 66,"c", 67,"d", 68,"e", 69,"f", 70,"g", 71,"h", 72,"i", 73,"j", 74,"k", 75,"l", 76,"m", 77,"n", 78,"o", 79,"p", 80,"q", 81,"r", 82,"s", 83,"t", 84,"u", 85,"v", 86,"w", 87,"x", 88,"y", 89,"z", 90];
			for (var i = 1; i < keyCodesChars.length; i += 2) {
				Helper.keyToCharMap.insert(keyCodesChars[i], keyCodesChars[i - 1]);
			}
			// console.log("Key to char map length: ");
			// console.log(Helper.keyToCharMap.ht);

// mark - GamePlay
	
			var Player = function () {
				// player object
				var size = 50;
				var geometryH = new THREE.BoxGeometry(size, 20, 20, 2, 2, 2); 
				var geometryV = new THREE.BoxGeometry(20, 20, size, 2, 2, 2); 
				var materialRed = new THREE.MeshLambertMaterial({ 
					color: 0x903535
				});

				var objectV = new THREE.Mesh(geometryV, materialRed);
				var objectH = new THREE.Mesh(geometryH, materialRed);
				objectH.add(objectV);

				this.object = new THREE.Object3D();
				this.object.position.y = 10;
				this.object.add(objectH);

				// player attack field
				var radius = 200;
				var geometry = new THREE.CylinderGeometry(radius, radius, 1, 32);
				var material = new THREE.MeshBasicMaterial({ 
					color: 0xff0000,
					transparent: true, 
					opacity: 0.2
				});
				this.attackField = new THREE.Mesh(geometry, material);
				this.attackField.radius = radius;
				this.object.add(this.attackField);

				// player contols
				this.movementControls = {
					movementParams: {
						// canJump: true,
						moveForward: false,
						moveBackward: false,
						moveLeft: false,
						moveRight: false,
						velocity: new THREE.Vector3()
					},
					onKeyDown: function (event) {
						var mp = this.movementParams;
						switch (event.keyCode) {
							case 38: // up
								mp.moveForward = true;
								break;
							case 37: // left
								mp.moveLeft = true; break;
							case 40: // down
								mp.moveBackward = true;
								break;
							case 39: // right
								mp.moveRight = true;
								break;
							// case 32: // space
							// 	if (mp.canJump === true ) 
							// 		mp.velocity.y += 350;
							// 	mp.canJump = false;
							// 	break;
						}
					},
					onKeyUp: function (event) {
						var mp = this.movementParams;
						switch(event.keyCode) {
							case 38: // up
								mp.moveForward = false;
								break;
							case 37: // left
								mp.moveLeft = false;
								break;
							case 40: // down
								mp.moveBackward = false;
								break;
							case 39: // right
								mp.moveRight = false;
								break;
						}
					}
				};

				var mc = this.movementControls;
				document.addEventListener('keydown', mc.onKeyDown.bind(mc), false);
				document.addEventListener('keyup', mc.onKeyUp.bind(mc), false);
			};
			
			var Bot = function (word) {
				this.word = word;
				this.rate = word.length;
				this.isDead = false;

				var size = Math.min(30, 4 * this.rate);
				var geometry = new THREE.BoxGeometry(size, size, size);
				var material = new THREE.MeshLambertMaterial({
					color: 0x808080
				});
				this.object = new THREE.Mesh(geometry, material);
				this.object.position.y = 10;

				Helper.positionImageText(this.word, this.object);
			};

			var Rocket = function (target) {
				this.target = target;

				var size = 5;
				var geometry = new THREE.BoxGeometry(size, size, size);
				var materialRed = new THREE.MeshLambertMaterial({ 
					color: 0x903535
				});

				var object = new THREE.Mesh(geometry, materialRed);
				this.object = object;
			};

// mark - 			
			
			var GamePlay = function (dictionary) {
				this.dictionary = dictionary;

				// canvas
				this.aspect = window.innerWidth / window.innerHeight;
				this.buttleFieldWidthUsed = 1000;
				this.buttleFieldHeightUsed = 1000;

				this.buttleFieldWidth = 1500;
				this.buttleFieldHeight = 1500;

				this.buttleFieldHeightTopDown = 1000;
				this.buttleFieldWidthTopDown = this.aspect * this.buttleFieldHeightTopDown;

				// graphics
				this.raycaster = null;
				this.scene = null;
				this.cameraTopDown = null;
				this.renderer = null;

				// game play
				this.prevTime = performance.now();

				this.bots = [];
				this.botsInAttackField = new HashTable();

				this.rockets = [];
				this.player = null;

				// initialization
				this.init.call(this);
				this.animate.call(this);

				document.addEventListener('keydown', this.onKeyDown.bind(this), false);
			};

			GamePlay.prototype.onKeyDown = function (event) {
				var code = event.keyCode;
				if (Helper.keyToCharMap.contains(code)) {
					var ch = Helper.keyToCharMap.get(code);
					// console.log("Char to fire: ");
					// console.log(ch);

					if (!this.botsInAttackField.isEmpty()) {
						var allBots = this.botsInAttackField.getAllValues();
						for(var i = 0; i < allBots.length; ++i) {
							var bot = allBots[i];
    						var rocket = new Rocket(bot);
    						this.rockets.push(rocket);

    						var pObject = this.player.object;
    						var rObject = rocket.object;
    						rObject.position.set(pObject.position.x, pObject.position.y, pObject.position.z);
    						this.scene.add(rObject);
						}
					}
				}
			};
			
			GamePlay.prototype.init = function () {
				this.initGraphics.call(this);

				this.initButtleField.call(this);
				this.initPlayer.call(this);
				this.initBots.call(this);
			};
			GamePlay.prototype.initGraphics = function () {
				// scene
				this.scene = new THREE.Scene();

				// camera
				var coef = 1;
				this.cameraTopDown = new THREE.OrthographicCamera(
					-0.5 * this.buttleFieldWidthTopDown * coef,
					0.5 * this.buttleFieldWidthTopDown * coef,
					0.5 * this.buttleFieldHeightTopDown * coef,
					-0.5 * this.buttleFieldHeightTopDown * coef,
					-0.00001, 1000000
				);
				this.cameraTopDown.position.set(1000, 1000, 1000);
				this.scene.add(this.cameraTopDown);

				this.cameraTopDown.lookAt(new THREE.Vector3());
				this.cameraTopDown.updateProjectionMatrix();
				

				// light
				var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
				light.position.set(0.5, 1, 0.75);
				this.scene.add(light);

				var directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
				directionalLight.position.set(0.5, 1, 0.75);
				this.scene.add(directionalLight);
				
				// raycaster
				this.raycaster = new THREE.Raycaster(
					new THREE.Vector3(), 
					new THREE.Vector3(), 
					0, 1000000
				);

				// renderer
				this.renderer = new THREE.WebGLRenderer();
				this.renderer.setClearColor(0xffffff);
				this.renderer.setPixelRatio(window.devicePixelRatio);
				this.renderer.setSize(window.innerWidth, window.innerHeight);

				document.body.appendChild(this.renderer.domElement);
			};
			GamePlay.prototype.initButtleField = function () {
				// buttlefield
				var geometry = new THREE.PlaneGeometry(this.buttleFieldWidth, this.buttleFieldHeight, 10, 10);
				geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
				var material = new THREE.MeshLambertMaterial({
					color: 0xcccccc
				});
				var buttleField = new THREE.Mesh(geometry, material);
				this.scene.add(buttleField);

				// background
				var geometryBG = new THREE.PlaneGeometry(1000000, 1000000, 10, 10);
				geometryBG.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
				var materialBG = new THREE.MeshLambertMaterial({
					color: 0xeeeeee
				});
				var buttleFieldBackground = new THREE.Mesh(geometryBG, materialBG);
				buttleFieldBackground.position.y = -1;
				this.scene.add(buttleFieldBackground);

				// center
				var materialBlue = new THREE.MeshBasicMaterial({ 
					// color: 0x353E90,
					color: 0xeeeeee
				});
				var size = 40;				
				var geometry = new THREE.CylinderGeometry(size, size, 1, 32);
				var center = new THREE.Mesh(geometry, materialBlue);
				this.scene.add(center);
			};
			GamePlay.prototype.initPlayer = function () {
				// player
				this.player = new Player();
				var pObject = this.player.object;
				this.scene.add(pObject);
			};
			GamePlay.prototype.initBots = function () {
				for (var i = 0; i < this.dictionary.length; ++i) {
					var word = dictionary[i];

					var bot = new Bot(word);
					// TODO:
					bot.hash = word + i;
					this.bots.push(bot);

					var w = this.buttleFieldWidthUsed;
					var h = this.buttleFieldHeightUsed;
					var radius = this.player.attackField.radius
					var x = Math.max(Math.floor(Math.random() * w - w * 0.5));
					var z = Math.floor(Math.random() * h - h * 0.5);
					var coord = [x, z];
					for (var j = 0; j < coord.length; ++j) {
						coord[j] = (coord[j] <= 0) ? Math.min(-radius, coord[j]) : Math.max(radius, coord[j]);
					}

					var bObject = bot.object;
					bObject.position.x = coord[0];
					bObject.position.y = 10;
					bObject.position.z = coord[1];
					this.scene.add(bObject);
				}
			};		
			GamePlay.prototype.animate = function () {
				requestAnimationFrame(this.animate.bind(this));
				if (true) {
					var time = performance.now();
					var delta = (time - this.prevTime) * 0.001;

					// player animation
					var pObject = this.player.object;
					var mp = this.player.movementControls.movementParams;
					mp.velocity.x -= mp.velocity.x * 10.0 * delta;
					mp.velocity.z -= mp.velocity.z * 10.0 * delta;
					// mp.velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
					if (mp.moveForward) 
						mp.velocity.z -= 400.0 * delta;
					if (mp.moveBackward) 
						mp.velocity.z += 400.0 * delta;
					if (mp.moveLeft) 
						mp.velocity.x -= 400.0 * delta;
					if (mp.moveRight) 
						mp.velocity.x += 400.0 * delta;
	
					// var down = new THREE.Vector3(0, -1, 0);
					// this.raycaster.set(pObject.position, down);
					// this.raycaster.ray.origin.y -= 10; // players foot
					// var intersections = this.raycaster.intersectObjects(this.bots);
					// var isOnObject = intersections.length > 0;
					// if (isOnObject === true) {
					// 	mp.velocity.y = Math.max(0, mp.velocity.y);
					// 	mp.canJump = true;
					// }
					
					// if (pObject.position.y < 10) {
					// 	mp.velocity.y = 0;
					// 	pObject.position.y = 10; // players center
					// 	mp.canJump = true;
					// }

					pObject.translateX(mp.velocity.x * delta);
					// pObject.translateY(mp.velocity.y * delta);
					pObject.translateZ(mp.velocity.z * delta);

					// this.cameraTopDown.translateX(mp.velocity.x * delta);
					// this.cameraTopDown.translateY(mp.velocity.y * delta);
					// this.cameraTopDown.translateZ(mp.velocity.z * delta);

					// TODO: destroy bots properly
					// bots animation
					var bots = [];
					for (var i = 0, flag = 0; i < this.bots.length; ++i, flag = 1 - flag) {
						var bot = this.bots[i];
						if (bot.isDead) {
							this.botsInAttackField.remove(bot.hash);
							continue;
						}

						var bObject = bot.object;
						var x = pObject.position.x - bObject.position.x;
						var y = 0;
						var z = pObject.position.z - bObject.position.z;

						var toPlayerFromBot = new THREE.Vector3(x, y, z);
						toPlayerFromBot.normalize();
						
						var toBotFromPlayer = new THREE.Vector3(-x, -y, -z);
						// toBotFromPlayer.normalize();
						
						// this.raycaster.set(pObject.position, toBotFromPlayer);
						// var intersections = this.raycaster.intersectObjects([bObject]);

						var target = toPlayerFromBot.clone();
					    // if (intersections.length > 0 && intersections[0].distance > this.player.attackField.radius) { 
					    if (toBotFromPlayer.length() > this.player.attackField.radius) { 
					    	var up = new THREE.Vector3(0, 1, 0);
					    	var toBotFromCenter = bObject.position.clone();
					    	if (flag) {
								target.crossVectors(toBotFromCenter, up);
					    	} else {
								target.crossVectors(up, toBotFromCenter);
					    	}
							target.normalize();

							this.botsInAttackField.remove(bot.hash);
					    } else {
					    	this.botsInAttackField.insert(bot.hash, bot);
					    }

						bObject.translateX(target.x * 10.0 * delta);
						bObject.translateY(target.y * 10.0 * delta);
						bObject.translateZ(target.z * 10.0 * delta);

						bots.push(bot);
					}
					this.bots = bots;

					// TODO: destroy rockets properly
					// rockets animation
					var rockets = [];
					for (var i = 0; i < this.rockets.length; ++i) {
						var rocket = this.rockets[i];
						var bot = rocket.target;

						var rObject = rocket.object;
						var bObject = bot.object;
						var x = bObject.position.x - rObject.position.x;
						var y = 0;
						var z = bObject.position.z - rObject.position.z;
						var toBotFromRocket = new THREE.Vector3(x, y, z);
						if (toBotFromRocket.length() > 0.5) {
 							toBotFromRocket.normalize();

 							var target = toBotFromRocket.clone();
 							rObject.translateX(target.x * 50.0 * delta);
							rObject.translateY(target.y * 50.0 * delta);
							rObject.translateZ(target.z * 50.0 * delta);

							rockets.push(rocket);
						} else {
							bot.isDead = true;
							this.botsInAttackField.remove(bot.hash);

							this.scene.remove(rObject);
							this.scene.remove(bObject);
						}
					}
					this.rockets = rockets;

					this.prevTime = time;
				}
				this.renderer.render(this.scene, this.cameraTopDown);
			};

			var dictionary = ["car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication", "car", "book", "developer", "sidewalk", "festival", "problem", "manager", "communication"];
			// console.log("Dictionary length: ");
			// console.log(dictionary.length);
			var gp = new GamePlay(dictionary);
		</script>
	</body>
</html>
